### 原理

所生成的图片，在内容上接近内容图，在风格上接近风格图。

因此需要定义**内容损失函数**和**风格损失函数**，经过加权后作为总体损失函数。

实现步骤：

	- 随机产生一张图片；
	- 在每轮迭代中，根据总体损失函数，调整图片的像素值；
	- 经过多轮迭代，得到优化后的图片。

### 内容损失函数

CNN具有抽象和理解图像的能力，因此可以考虑将各个卷积层的输出作为图像的内容。

以VGG19为例，其中包括了多个卷积层、池化层，以及最后的全连接层。

![VGG19](https://github.com/ACBGZM/MyPostImage/raw/master/dl-labimg/styletransfer/VGG19.png)

使用conv4_2的输出作为图像的内容表示，定义内容损失函数如下：
$$
L_{content}(\vec p, \vec x, l) = \frac {1}{2} \sum _{i, j} (F^l_{ij} - P^l_{ij}) ^2
$$
p：内容图，x：生成图，得到2个四维tensor，相减、平方、求和，除以归一化系数，得到内容上的差异。

### 风格损失函数

使用卷积层各个特征图之间的互相关作为图像的风格。以`conv1_1`为例

- depth = 64，共包含64个特征图即feature map，或者叫图像的深度、通道的个数
- 每个特征图都是对上一层输出的一种理解，可以类比成64个人对同一幅画的不同理解
- 这些人可能分别偏好不同风格
- 当图像是一种风格，可能一部分人很喜欢，另一部分人不喜欢
- 64个人之间理解的差异可以用特征图的互相关表示，这里使用`Gram`矩阵计算互相关
- 不同的风格会导致差异化的互相关结果

`Gram`矩阵的计算如下，如果有64个特征图，那么`Gram`矩阵的大小是`64*64`，第`i`行第`j`列的值表示第`i`个特征图和第`j`个特征图之间的互相关，用内积计算
$$
G^l_{ij} = \sum _k F^l_{ik}F^l_{jk}
$$
*（l：卷积层数）*

风格损失函数定义如下，对多个卷积层的风格表示差异进行加权
$$
E_l = \frac {1}{4N^2_lM^2_l}\sum_{i,j}(G^l_{ij}-A^l_{ij})
$$

$$
L_{style}(\vec a,\vec x) = \sum^L_{i=0}\omega_lE_l
$$

*（G：生成图的Gram矩阵，A：风格图的Gram矩阵，E：在某个卷积层上的风格差异。多个卷积层风格差异加权求和，得到风格总损失函数L_style）*

这里我们使用`conv1_1`、`conv2_1`、`conv3_1`、`conv4_1`、`conv5_1`五个卷积层，进行风格损失函数的计算，不同的权重会导致不同的迁移效果。

### 总损失函数

$$
L_{total}(\vec p,\vec a,\vec x)=\alpha L_{content}(\vec p,\vec x)+ \beta L_{style}(\vec a,\vec x)
$$

p：内容图；a：风格图；x：生成图。α和β是内容和风格的加权。